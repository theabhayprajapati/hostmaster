use std::fs;
use std::process::Command;
use serde::{Serialize, Deserialize};
use std::io::Write;
use tempfile::NamedTempFile;

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
struct HostEntry {
    id: String,
    ip: String,
    domain: String,
    enabled: bool,
    is_system: bool,
}

// --- READ COMMAND ---
#[tauri::command]
fn read_hosts_file() -> Result<Vec<HostEntry>, String> {
    let content = fs::read_to_string("/etc/hosts").map_err(|e| e.to_string())?;
    
    let mut entries = Vec::new();
    for (i, line) in content.lines().enumerate() {
        if line.trim().is_empty() { continue; }
        
        let is_commented = line.trim().starts_with('#');
        let clean_line = line.replace("#", "");
        let parts: Vec<&str> = clean_line.split_whitespace().collect();
        
        if parts.len() >= 2 {
            let ip = parts[0].to_string();
            let domain = parts[1].to_string();
            
            entries.push(HostEntry {
                id: i.to_string(),
                ip,
                domain: domain.clone(),
                enabled: !is_commented,
                is_system: domain == "localhost" || domain == "broadcasthost",
            });
        }
    }
    Ok(entries)
}

// --- SAVE COMMAND ---
#[tauri::command]
fn save_hosts_file(entries: Vec<HostEntry>) -> Result<String, String> {
    let mut file_content = String::new();
    file_content.push_str("## Generated by HostMaster\n");
    
    for entry in entries {
        let prefix = if entry.enabled { "" } else { "# " };
        file_content.push_str(&format!("{}{}\t{}\n", prefix, entry.ip, entry.domain));
    }

    let mut temp_file = NamedTempFile::new().map_err(|e| e.to_string())?;
    write!(temp_file, "{}", file_content).map_err(|e| e.to_string())?;
    let temp_path = temp_file.path().to_str().unwrap().to_string();

    #[cfg(target_os = "macos")]
    {
        let script = format!(
            "do shell script \"cat {} > /etc/hosts\" with administrator privileges", 
            temp_path
        );
        
        let output = Command::new("osascript")
            .arg("-e")
            .arg(script)
            .output()
            .map_err(|e| e.to_string())?;

        if !output.status.success() {
            return Err("User cancelled or denied permission".to_string());
        }
    }

    #[cfg(target_os = "linux")]
    {
        let output = Command::new("pkexec")
            .arg("cp")
            .arg(&temp_path)
            .arg("/etc/hosts")
            .output()
            .map_err(|e| e.to_string())?;

        if !output.status.success() {
            return Err("Permission denied".to_string());
        }
    }

    Ok("Saved successfully".into())
}

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .plugin(tauri_plugin_opener::init())
        .invoke_handler(tauri::generate_handler![read_hosts_file, save_hosts_file])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
